package top.cliffside;

/**
 * spring中可以使用如下方式实现事务的控制
 *
 * 1 编程式(不推荐)
 *
 * 2 声明式(掌握)
 *
 *          1) 注解(简单,必会)
 *
 *    2) XML配置(繁琐,了解)
 * @author cliffside
 * @date 2021-05-15 20:05
 * 1.     事务的概念
 *
 * 事务（Transaction）指的是一个操作序列，该操作序列中的多个操作要么都做，
 * 要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位，
 * 由DBMS中的事务管理子系统负责事务的处理。
 *
 * 目前常用的存储引擎有InnoDB（MySQL5.5以后默认的存储引擎）
 * 和MyISAM（MySQL5.5之前默认的存储引擎），其中InnoDB支持事务处理机制，而MyISAM不支持。
 */
public class Readme {
}
/**
 * 2.     事务的特性
 *
 * 事务处理可以确保除非事务性序列内的所有操作都成功完成，否则不会永久更新面向数据的资源。
 * 通过将一组相关操作组合为一个要么全部成功要么全部失败的序列，
 * 可以简化错误恢复并使应用程序更加可靠。
 *
 * 但并不是所有的操作序列都可以称为事务，这是因为一个操作序列要成为事务，
 * 必须满足事务的原子性（Atomicity）、
 * 一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。
 * 这四个特性简称为ACID特性。
 *
 * 1)     原子性
 *
 * 原子是自然界最小的颗粒，具有不可再分的特性。事务中的所有操作可以看做一个原子，
 * 事务是应用中不可再分的最小的逻辑执行体。
 *
 * 使用事务对数据进行修改的操作序列，要么全部执行，要么全不执行。
 * 通常，某个事务中的操作都具有共同的目标，并且是相互依赖的。
 * 如果数据库系统只执行这些操作中的一部分，则可能会破坏事务的总体目标，
 * 而原子性消除了系统只处理部分操作的可能性。
 *
 * 2)      一致性
 *
 * 一致性是指事务执行的结果必须使数据库从一个一致性状态，
 * 变到另一个一致性状态。当数据库中只包含事务成功提交的结果时，
 * 数据库处于一致性状态。一致性是通过原子性来保证的。
 *
 * 例如：在转账时，只有保证转出和转入的金额一致才能构成事务。
 * 也就是说事务发生前和发生后，数据的总额依然匹配。
 *
 * 3)      隔离性
 *
 * 隔离性是指各个事务的执行互不干扰，任意一个事务的内部操作对其他并发的事务，都
 * 是隔离的。也就是说：并发执行的事务之间既不能看到对方的中间状态，也不能相互影响。
 *
 * 例如：在转账时，只有当A账户中的转出和B账户中转入操作都执行成功后才能看到A账户中的金额减少
 * 以及B账户中的金额增多。并且其他的事务对于转账操作的事务是不能产生任何影响的。
 *
 * 4)     持久性
 *
 * 持久性指事务一旦提交，对数据所做的任何改变，都要记录到永久存储器中，
 * 通常是保存进物理数据库，即使数据库出现故障，提交的数据也应该能够恢复。
 * 但如果是由于外部原因导致的数据库故障，如硬盘被损坏，那么之前提交的数据则有可能会丢失。
 */

/**
 * 3.     事务的并发问题
 *
 * 脏读（Dirty read）
 *
 * 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，
 * 这时另外一个事务也访问了这个数据，然后使用了这个数据。
 * 因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，
 * 依据“脏数据”所做的操作可能是不正确的。
 *
 * 不可重复读
 *
 * （Unrepeatableread）: 指在一个事务内多次读同一数据。
 * 在这个事务还没有结束时，另一个事务也访问该数据。
 * 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致
 * 第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，
 * 因此称为不可重复读。
 *
 * 幻读
 *
 * （Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，
 * 接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，
 * 第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
 *
 * 不可重复度和幻读区别：
 *
 * 不可重复读的重点是修改，幻读的重点在于新增或者删除。
 *
 * 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表
 *
 * 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：
 * 事务1中的A先生读取自己的工资为 1000的操作还没完成，
 * 事务2中的B先生就修改了A的工资为2000，
 * 导 致A再读自己的工资时工资变为 2000；这就是不可重复读。
 *
 * 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：
 * 假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，
 * 共查到4条记录，这时事务2又插入了一条工资大于3000的记录，
 * 事务1再次读取时查到的记录就变为了5条，这样就导致了幻读
 */

/**
 * 4.事务的隔离级别
 *
 * 事务的隔离级别用于决定如何控制并发用户读写数据的操作。数据库是允许多用户并发访问的，
 * 如果多个用户同时开启事务并对同一数据进行读写操作的话，有可能会出现脏读、
 * 不可重复读和幻读问题，所以MySQL中提供了四种隔离级别来解决上述问题。
 *
 * 事务的隔离级别从低到高依次为
 * READ UNCOMMITTED、
 * READ COMMITTED、
 * REPEATABLE READ以及
 * SERIALIZABLE，隔离级别越低，越能支持高并发的数据库操作。
 *
 *   隔离级别             脏读  不可重复读  幻读
 * READ UNCOMMITTED      √      √        √
 *   READ COMMITTED      ×       √        √
 *   REPEATABLE READ     ×       ×         √
 *  SERIALIZABLE         ×       ×         ×
 */